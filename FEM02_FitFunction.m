function [sFEM] = FEM02_FitFunction(sFEM,coefs)
tic

% Colin Ophus and Ellis Kennedy - Sept 2019
% FEM analysis 02 - Fitting function for radial signal, finds center of FEM
% pattern. Requires rough estimates of eleven fitting parameters (below).

% Inputs: 1 - The output sFEM file from FEM)1_MaskCoords; 2 - the second input is
% optional, use of the second input fixes the fitting parameters instead of
% applying a fitting function

flagReportError = true;
flagPlot = true;
powerPlot = 1;
skipFit = 7;

if ~isfield(sFEM,'fitCoefs')
%     %sample inputs, see guide below
    sFEM.fitCoefs = [ ...
        280 267 0.95 0.07 ...
        430 ...
        1000 26 ...
        137 700 40 14 ...
        ];
  % Coefs guide: 1) x-direction center, 2) y-direction center...
  % 3) C fitting in ellipse, 4) B fit in ellipse...
  % 5) intensity beyond first ring not on other ring...
  % 6) intensity between bright spot and first ring...
  % 7) ring width, 8) ring radius, 9) second ring radius...
  % 10) inner Gaussian tail of ring, 11) outer Gaussian tail
   
end
if ~isfield(sFEM,'basis')
    sFEM.basis = [sFEM.xa(:) sFEM.ya(:)];
end

sFEM.fitOptions = optimset( ...
    'TolX',1e-8,... 
    'TolFun',1e-8,... 
    'MaxFunEvals',1e5,...
    'maxiter',1e5,...
    'display','off');
% these are recommended for real data sets, but can be modified if
% convergence is not achieved


sFEM.fitFun = @(c,x) c(5) ...
    ...
    + c(6)*exp((-1/2/c(7)^2) ...
    *((x(:,1) - c(1)).^2 ...
    + c(3)*(x(:,2) - c(2)).^2 ...
    + c(4)*(x(:,1) - c(1)).*(x(:,2) - c(2)))) ...
    ...
    + c(9)*exp((-1/2/c(10)^2)* ...
      abs(c(8) - sqrt( ...
      (x(:,1) - c(1)).^2 ...
    + c(3)*(x(:,2) - c(2)).^2 ...
    + c(4)*(x(:,1) - c(1)).*(x(:,2) - c(2)))).^2) ...
    .* (c(8)^2 ...
    > ((x(:,1) - c(1)).^2 ...
    + c(3)*(x(:,2) - c(2)).^2 ...
    + c(4)*(x(:,1) - c(1)).*(x(:,2) - c(2)))) ...
    ...
    + c(9)*exp((-1/2/c(11)^2)* ...
      abs(c(8) - sqrt( ...
      (x(:,1) - c(1)).^2 ...
    + c(3)*(x(:,2) - c(2)).^2 ...
    + c(4)*(x(:,1) - c(1)).*(x(:,2) - c(2)))).^2) ...
    .* (c(8)^2 ...
    < ((x(:,1) - c(1)).^2 ...
    + c(3)*(x(:,2) - c(2)).^2 ...
    + c(4)*(x(:,1) - c(1)).*(x(:,2) - c(2))));

% If output is specified, perform fitting
if nargout > 0 && nargin < 2
    inds2D = sub2ind(sFEM.stackSize(1:2),sFEM.xa,sFEM.ya);
    maskFit = mod(inds2D,skipFit) == 0;
    
    sFEM.fitCoefs = lsqcurvefit(sFEM.fitFun, ...
        sFEM.fitCoefs,...
        sFEM.basis(sFEM.mask(:) & maskFit(:),:),...
        double(sFEM.CBEDmean(sFEM.mask(:) & maskFit(:))),...
        [],[],sFEM.fitOptions);
end
if nargin == 2
    sFEM.fitCoefs = coefs;
end


% Plotting
if flagPlot == true
    Imeas = max(sFEM.CBEDmean,0);
    Ifit = reshape(sFEM.fitFun(sFEM.fitCoefs,sFEM.basis), ...
        sFEM.stackSize(1:2)); 
    
    Ip1 = Imeas.^powerPlot;
    Ip2 = Ifit .^powerPlot;
    t = atan2(sFEM.ya - sFEM.fitCoefs(2),...
        sFEM.xa - sFEM.fitCoefs(1));
    w = double(mod(t,pi/8) < pi/16);
    w(~sFEM.mask & (w == 1)) = 0;
    Ip = Ip1 .* w ...
        + Ip2 .* (1-w);
    Ip = real(Ip);
%     Ip = 1000*w;
intRange = [min(Ip2(sFEM.mask)) max(Ip2(sFEM.mask))];  %for real data
     
    figure(13)
    clf
    imagesc(Ip)
    axis equal off
    colormap(jet(256))
    set(gca,'position',[0 0 1 1])
    caxis(intRange)
    
    if flagReportError == true
        fitError = mean(abs( ...
            Imeas(sFEM.mask) - Ifit(sFEM.mask))) ...
            / mean(abs(Imeas(sFEM.mask)));
        disp(['Mean abs. diff. = ' ...
            sprintf('%.04f',fitError*100) '%'])
        
    end
end



toc
end